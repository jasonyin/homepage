'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.remapEvent = remapEvent;
exports.getTransformPropertyName = getTransformPropertyName;
exports.supportsCssCustomProperties = supportsCssCustomProperties;
exports.applyPassive = applyPassive;
exports.saveElementTabState = saveElementTabState;
exports.restoreElementTabState = restoreElementTabState;
//    Copyright 2017 Jason Yin <jasonyin@outlook.com>
// 
//    Licensed under the Apache License, Version 2.0 (the "License");
//    you may not use this file except in compliance with the License.
//    You may obtain a copy of the License at
// 
//        http://www.apache.org/licenses/LICENSE-2.0
// 
//    Unless required by applicable law or agreed to in writing, software
//    distributed under the License is distributed on an "AS IS" BASIS,
//    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//    See the License for the specific language governing permissions and
//    limitations under the License.

var TAB_DATA = 'data-jy-tabindex';
var TAB_DATA_HANDLED = 'data-jy-tabindex-handled';

var storedTransformPropertyName_ = void 0;
var supportsPassive_ = void 0;

// Remap touch events to pointer events, if the browser doesn't support touch events.
function remapEvent(eventName) {
  var globalObj = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : window;

  if (!('ontouchstart' in globalObj.document)) {
    switch (eventName) {
      case 'touchstart':
        return 'pointerdown';
      case 'touchmove':
        return 'pointermove';
      case 'touchend':
        return 'pointerup';
      default:
        return eventName;
    }
  }

  return eventName;
}

// Choose the correct transform property to use on the current browser.
function getTransformPropertyName() {
  var globalObj = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : window;
  var forceRefresh = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

  if (storedTransformPropertyName_ === undefined || forceRefresh) {
    var el = globalObj.document.createElement('div');
    var transformPropertyName = 'transform' in el.style ? 'transform' : '-webkit-transform';
    storedTransformPropertyName_ = transformPropertyName;
  }

  return storedTransformPropertyName_;
}

// Determine whether the current browser supports CSS properties.
function supportsCssCustomProperties() {
  var globalObj = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : window;

  if ('CSS' in globalObj) {
    return globalObj.CSS.supports('(--color: red)');
  }
  return false;
}

// Determine whether the current browser supports passive event listeners, and if so, use them.
function applyPassive() {
  var globalObj = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : window;
  var forceRefresh = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

  if (supportsPassive_ === undefined || forceRefresh) {
    var isSupported = false;
    try {
      globalObj.document.addEventListener('test', null, { get passive() {
          isSupported = true;
        } });
    } catch (e) {}

    supportsPassive_ = isSupported;
  }

  return supportsPassive_ ? { passive: true } : false;
}

// Save the tab state for an element.
function saveElementTabState(el) {
  if (el.hasAttribute('tabindex')) {
    el.setAttribute(TAB_DATA, el.getAttribute('tabindex'));
  }
  el.setAttribute(TAB_DATA_HANDLED, true);
}

// Restore the tab state for an element, if it was saved.
function restoreElementTabState(el) {
  // Only modify elements we've already handled, in case anything was dynamically added since we saved state.
  if (el.hasAttribute(TAB_DATA_HANDLED)) {
    if (el.hasAttribute(TAB_DATA)) {
      el.setAttribute('tabindex', el.getAttribute(TAB_DATA));
      el.removeAttribute(TAB_DATA);
    } else {
      el.removeAttribute('tabindex');
    }
    el.removeAttribute(TAB_DATA_HANDLED);
  }
}
//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImRyYXdlci91dGlscy5qcyJdLCJuYW1lcyI6WyJyZW1hcEV2ZW50IiwiZ2V0VHJhbnNmb3JtUHJvcGVydHlOYW1lIiwic3VwcG9ydHNDc3NDdXN0b21Qcm9wZXJ0aWVzIiwiYXBwbHlQYXNzaXZlIiwic2F2ZUVsZW1lbnRUYWJTdGF0ZSIsInJlc3RvcmVFbGVtZW50VGFiU3RhdGUiLCJUQUJfREFUQSIsIlRBQl9EQVRBX0hBTkRMRUQiLCJzdG9yZWRUcmFuc2Zvcm1Qcm9wZXJ0eU5hbWVfIiwic3VwcG9ydHNQYXNzaXZlXyIsImV2ZW50TmFtZSIsImdsb2JhbE9iaiIsIndpbmRvdyIsImRvY3VtZW50IiwiZm9yY2VSZWZyZXNoIiwidW5kZWZpbmVkIiwiZWwiLCJjcmVhdGVFbGVtZW50IiwidHJhbnNmb3JtUHJvcGVydHlOYW1lIiwic3R5bGUiLCJDU1MiLCJzdXBwb3J0cyIsImlzU3VwcG9ydGVkIiwiYWRkRXZlbnRMaXN0ZW5lciIsInBhc3NpdmUiLCJlIiwiaGFzQXR0cmlidXRlIiwic2V0QXR0cmlidXRlIiwiZ2V0QXR0cmlidXRlIiwicmVtb3ZlQXR0cmlidXRlIl0sIm1hcHBpbmdzIjoiOzs7OztRQXFCZ0JBLFUsR0FBQUEsVTtRQWtCQUMsd0IsR0FBQUEsd0I7UUFXQUMsMkIsR0FBQUEsMkI7UUFRQUMsWSxHQUFBQSxZO1FBZ0JBQyxtQixHQUFBQSxtQjtRQVFBQyxzQixHQUFBQSxzQjtBQWxGaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsSUFBTUMsV0FBVyxrQkFBakI7QUFDQSxJQUFNQyxtQkFBbUIsMEJBQXpCOztBQUVBLElBQUlDLHFDQUFKO0FBQ0EsSUFBSUMseUJBQUo7O0FBRUE7QUFDTyxTQUFTVCxVQUFULENBQW9CVSxTQUFwQixFQUFtRDtBQUFBLE1BQXBCQyxTQUFvQix1RUFBUkMsTUFBUTs7QUFDeEQsTUFBSSxFQUFFLGtCQUFrQkQsVUFBVUUsUUFBOUIsQ0FBSixFQUE2QztBQUMzQyxZQUFRSCxTQUFSO0FBQ0UsV0FBSyxZQUFMO0FBQ0UsZUFBTyxhQUFQO0FBQ0YsV0FBSyxXQUFMO0FBQ0UsZUFBTyxhQUFQO0FBQ0YsV0FBSyxVQUFMO0FBQ0UsZUFBTyxXQUFQO0FBQ0Y7QUFDRSxlQUFPQSxTQUFQO0FBUko7QUFVRDs7QUFFRCxTQUFPQSxTQUFQO0FBQ0Q7O0FBRUQ7QUFDTyxTQUFTVCx3QkFBVCxHQUE0RTtBQUFBLE1BQTFDVSxTQUEwQyx1RUFBOUJDLE1BQThCO0FBQUEsTUFBdEJFLFlBQXNCLHVFQUFQLEtBQU87O0FBQ2pGLE1BQUlOLGlDQUFpQ08sU0FBakMsSUFBOENELFlBQWxELEVBQWdFO0FBQzlELFFBQU1FLEtBQUtMLFVBQVVFLFFBQVYsQ0FBbUJJLGFBQW5CLENBQWlDLEtBQWpDLENBQVg7QUFDQSxRQUFNQyx3QkFBeUIsZUFBZUYsR0FBR0csS0FBbEIsR0FBMEIsV0FBMUIsR0FBd0MsbUJBQXZFO0FBQ0FYLG1DQUErQlUscUJBQS9CO0FBQ0Q7O0FBRUQsU0FBT1YsNEJBQVA7QUFDRDs7QUFFRDtBQUNPLFNBQVNOLDJCQUFULEdBQXlEO0FBQUEsTUFBcEJTLFNBQW9CLHVFQUFSQyxNQUFROztBQUM5RCxNQUFJLFNBQVNELFNBQWIsRUFBd0I7QUFDdEIsV0FBT0EsVUFBVVMsR0FBVixDQUFjQyxRQUFkLENBQXVCLGdCQUF2QixDQUFQO0FBQ0Q7QUFDRCxTQUFPLEtBQVA7QUFDRDs7QUFFRDtBQUNPLFNBQVNsQixZQUFULEdBQWdFO0FBQUEsTUFBMUNRLFNBQTBDLHVFQUE5QkMsTUFBOEI7QUFBQSxNQUF0QkUsWUFBc0IsdUVBQVAsS0FBTzs7QUFDckUsTUFBSUwscUJBQXFCTSxTQUFyQixJQUFrQ0QsWUFBdEMsRUFBb0Q7QUFDbEQsUUFBSVEsY0FBYyxLQUFsQjtBQUNBLFFBQUk7QUFDRlgsZ0JBQVVFLFFBQVYsQ0FBbUJVLGdCQUFuQixDQUFvQyxNQUFwQyxFQUE0QyxJQUE1QyxFQUFrRCxFQUFDLElBQUlDLE9BQUosR0FBYztBQUMvREYsd0JBQWMsSUFBZDtBQUNELFNBRmlELEVBQWxEO0FBR0QsS0FKRCxDQUlFLE9BQU9HLENBQVAsRUFBVSxDQUFHOztBQUVmaEIsdUJBQW1CYSxXQUFuQjtBQUNEOztBQUVELFNBQU9iLG1CQUFtQixFQUFDZSxTQUFTLElBQVYsRUFBbkIsR0FBcUMsS0FBNUM7QUFDRDs7QUFFRDtBQUNPLFNBQVNwQixtQkFBVCxDQUE2QlksRUFBN0IsRUFBaUM7QUFDdEMsTUFBSUEsR0FBR1UsWUFBSCxDQUFnQixVQUFoQixDQUFKLEVBQWlDO0FBQy9CVixPQUFHVyxZQUFILENBQWdCckIsUUFBaEIsRUFBMEJVLEdBQUdZLFlBQUgsQ0FBZ0IsVUFBaEIsQ0FBMUI7QUFDRDtBQUNEWixLQUFHVyxZQUFILENBQWdCcEIsZ0JBQWhCLEVBQWtDLElBQWxDO0FBQ0Q7O0FBRUQ7QUFDTyxTQUFTRixzQkFBVCxDQUFnQ1csRUFBaEMsRUFBb0M7QUFDekM7QUFDQSxNQUFJQSxHQUFHVSxZQUFILENBQWdCbkIsZ0JBQWhCLENBQUosRUFBdUM7QUFDckMsUUFBSVMsR0FBR1UsWUFBSCxDQUFnQnBCLFFBQWhCLENBQUosRUFBK0I7QUFDN0JVLFNBQUdXLFlBQUgsQ0FBZ0IsVUFBaEIsRUFBNEJYLEdBQUdZLFlBQUgsQ0FBZ0J0QixRQUFoQixDQUE1QjtBQUNBVSxTQUFHYSxlQUFILENBQW1CdkIsUUFBbkI7QUFDRCxLQUhELE1BR087QUFDTFUsU0FBR2EsZUFBSCxDQUFtQixVQUFuQjtBQUNEO0FBQ0RiLE9BQUdhLGVBQUgsQ0FBbUJ0QixnQkFBbkI7QUFDRDtBQUNGIiwiZmlsZSI6ImRyYXdlci91dGlscy5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8vICAgIENvcHlyaWdodCAyMDE3IEphc29uIFlpbiA8amFzb255aW5Ab3V0bG9vay5jb20+XG4vLyBcbi8vICAgIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4vLyAgICB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4vLyAgICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vIFxuLy8gICAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy8gXG4vLyAgICBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyAgICBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4vLyAgICBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vICAgIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vICAgIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG5jb25zdCBUQUJfREFUQSA9ICdkYXRhLWp5LXRhYmluZGV4JztcbmNvbnN0IFRBQl9EQVRBX0hBTkRMRUQgPSAnZGF0YS1qeS10YWJpbmRleC1oYW5kbGVkJztcblxubGV0IHN0b3JlZFRyYW5zZm9ybVByb3BlcnR5TmFtZV87XG5sZXQgc3VwcG9ydHNQYXNzaXZlXztcblxuLy8gUmVtYXAgdG91Y2ggZXZlbnRzIHRvIHBvaW50ZXIgZXZlbnRzLCBpZiB0aGUgYnJvd3NlciBkb2Vzbid0IHN1cHBvcnQgdG91Y2ggZXZlbnRzLlxuZXhwb3J0IGZ1bmN0aW9uIHJlbWFwRXZlbnQoZXZlbnROYW1lLCBnbG9iYWxPYmogPSB3aW5kb3cpIHtcbiAgaWYgKCEoJ29udG91Y2hzdGFydCcgaW4gZ2xvYmFsT2JqLmRvY3VtZW50KSkge1xuICAgIHN3aXRjaCAoZXZlbnROYW1lKSB7XG4gICAgICBjYXNlICd0b3VjaHN0YXJ0JzpcbiAgICAgICAgcmV0dXJuICdwb2ludGVyZG93bic7XG4gICAgICBjYXNlICd0b3VjaG1vdmUnOlxuICAgICAgICByZXR1cm4gJ3BvaW50ZXJtb3ZlJztcbiAgICAgIGNhc2UgJ3RvdWNoZW5kJzpcbiAgICAgICAgcmV0dXJuICdwb2ludGVydXAnO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIGV2ZW50TmFtZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZXZlbnROYW1lO1xufVxuXG4vLyBDaG9vc2UgdGhlIGNvcnJlY3QgdHJhbnNmb3JtIHByb3BlcnR5IHRvIHVzZSBvbiB0aGUgY3VycmVudCBicm93c2VyLlxuZXhwb3J0IGZ1bmN0aW9uIGdldFRyYW5zZm9ybVByb3BlcnR5TmFtZShnbG9iYWxPYmogPSB3aW5kb3csIGZvcmNlUmVmcmVzaCA9IGZhbHNlKSB7XG4gIGlmIChzdG9yZWRUcmFuc2Zvcm1Qcm9wZXJ0eU5hbWVfID09PSB1bmRlZmluZWQgfHwgZm9yY2VSZWZyZXNoKSB7XG4gICAgY29uc3QgZWwgPSBnbG9iYWxPYmouZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgY29uc3QgdHJhbnNmb3JtUHJvcGVydHlOYW1lID0gKCd0cmFuc2Zvcm0nIGluIGVsLnN0eWxlID8gJ3RyYW5zZm9ybScgOiAnLXdlYmtpdC10cmFuc2Zvcm0nKTtcbiAgICBzdG9yZWRUcmFuc2Zvcm1Qcm9wZXJ0eU5hbWVfID0gdHJhbnNmb3JtUHJvcGVydHlOYW1lO1xuICB9XG5cbiAgcmV0dXJuIHN0b3JlZFRyYW5zZm9ybVByb3BlcnR5TmFtZV87XG59XG5cbi8vIERldGVybWluZSB3aGV0aGVyIHRoZSBjdXJyZW50IGJyb3dzZXIgc3VwcG9ydHMgQ1NTIHByb3BlcnRpZXMuXG5leHBvcnQgZnVuY3Rpb24gc3VwcG9ydHNDc3NDdXN0b21Qcm9wZXJ0aWVzKGdsb2JhbE9iaiA9IHdpbmRvdykge1xuICBpZiAoJ0NTUycgaW4gZ2xvYmFsT2JqKSB7XG4gICAgcmV0dXJuIGdsb2JhbE9iai5DU1Muc3VwcG9ydHMoJygtLWNvbG9yOiByZWQpJyk7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG4vLyBEZXRlcm1pbmUgd2hldGhlciB0aGUgY3VycmVudCBicm93c2VyIHN1cHBvcnRzIHBhc3NpdmUgZXZlbnQgbGlzdGVuZXJzLCBhbmQgaWYgc28sIHVzZSB0aGVtLlxuZXhwb3J0IGZ1bmN0aW9uIGFwcGx5UGFzc2l2ZShnbG9iYWxPYmogPSB3aW5kb3csIGZvcmNlUmVmcmVzaCA9IGZhbHNlKSB7XG4gIGlmIChzdXBwb3J0c1Bhc3NpdmVfID09PSB1bmRlZmluZWQgfHwgZm9yY2VSZWZyZXNoKSB7XG4gICAgbGV0IGlzU3VwcG9ydGVkID0gZmFsc2U7XG4gICAgdHJ5IHtcbiAgICAgIGdsb2JhbE9iai5kb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCd0ZXN0JywgbnVsbCwge2dldCBwYXNzaXZlKCkge1xuICAgICAgICBpc1N1cHBvcnRlZCA9IHRydWU7XG4gICAgICB9fSk7XG4gICAgfSBjYXRjaCAoZSkgeyB9XG5cbiAgICBzdXBwb3J0c1Bhc3NpdmVfID0gaXNTdXBwb3J0ZWQ7XG4gIH1cblxuICByZXR1cm4gc3VwcG9ydHNQYXNzaXZlXyA/IHtwYXNzaXZlOiB0cnVlfSA6IGZhbHNlO1xufVxuXG4vLyBTYXZlIHRoZSB0YWIgc3RhdGUgZm9yIGFuIGVsZW1lbnQuXG5leHBvcnQgZnVuY3Rpb24gc2F2ZUVsZW1lbnRUYWJTdGF0ZShlbCkge1xuICBpZiAoZWwuaGFzQXR0cmlidXRlKCd0YWJpbmRleCcpKSB7XG4gICAgZWwuc2V0QXR0cmlidXRlKFRBQl9EQVRBLCBlbC5nZXRBdHRyaWJ1dGUoJ3RhYmluZGV4JykpO1xuICB9XG4gIGVsLnNldEF0dHJpYnV0ZShUQUJfREFUQV9IQU5ETEVELCB0cnVlKTtcbn1cblxuLy8gUmVzdG9yZSB0aGUgdGFiIHN0YXRlIGZvciBhbiBlbGVtZW50LCBpZiBpdCB3YXMgc2F2ZWQuXG5leHBvcnQgZnVuY3Rpb24gcmVzdG9yZUVsZW1lbnRUYWJTdGF0ZShlbCkge1xuICAvLyBPbmx5IG1vZGlmeSBlbGVtZW50cyB3ZSd2ZSBhbHJlYWR5IGhhbmRsZWQsIGluIGNhc2UgYW55dGhpbmcgd2FzIGR5bmFtaWNhbGx5IGFkZGVkIHNpbmNlIHdlIHNhdmVkIHN0YXRlLlxuICBpZiAoZWwuaGFzQXR0cmlidXRlKFRBQl9EQVRBX0hBTkRMRUQpKSB7XG4gICAgaWYgKGVsLmhhc0F0dHJpYnV0ZShUQUJfREFUQSkpIHtcbiAgICAgIGVsLnNldEF0dHJpYnV0ZSgndGFiaW5kZXgnLCBlbC5nZXRBdHRyaWJ1dGUoVEFCX0RBVEEpKTtcbiAgICAgIGVsLnJlbW92ZUF0dHJpYnV0ZShUQUJfREFUQSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsLnJlbW92ZUF0dHJpYnV0ZSgndGFiaW5kZXgnKTtcbiAgICB9XG4gICAgZWwucmVtb3ZlQXR0cmlidXRlKFRBQl9EQVRBX0hBTkRMRUQpO1xuICB9XG59XG4iXX0=
